# 进程和线程

**由来**: 他们均是随者 **分时操作系统 (time-shared system)** 的出现而出现的

- 分时操作系统意味着**多个用户/多个程序**





**线程**: 程序计数器, 寄存器, execution flags, stack





**程序计数器**: 这个寄存器中保存着执行指令的地址



## 进程 (process)

**进程是执行中的一个程序** (程序只是一个被动实体)

- 进程强调 **protection (保护)**



## 进程拥有的资源

#### 1. 内存中

**栈 (stack section)**

- 执行栈 (execution stack)
- 调用函数时的临时数据 (函数参数, 返回地址和局部变量)



**堆 (heap section)**

- 进程运行期间动态分配的内存



**数据段 (data)**

- 全局变量



**文本段 (text)**

- 代码

**从上到下**



#### 2. 寄存器中

- **程序计数器 (program counter)**
- **(stack pointer)**
- **等**



#### 3. I/O状态

- **打开的文件**
- **网络连接**





#### 从线程角度看

- **私有的**: 内存中的**栈**, CPU中的寄存器 (包括程序计数器)
  - 私有的内容保存在 **线程控制块 (thread control block)** 中

- **共享的**:  内存中的**文本段**, **数据段**, **堆**, **I/O状态**

**(私有: stack, register, 共享: code, data, heap)**



#### 如何运行一个进程

**载入 + 跳到第一个指令**

- 载入进程的状态 (寄存器, 程序计数器, 栈指针) 到CPU
- 载入环境
- 跳到程序计数器所指向的指令





## 进程的状态

通过 **进程控制块 (PCB)** 来实现

- PCB 存在于内核态, 由内核管理.
- 在 进程调度  中, **进程调度算法会选择下一个PCB来执行**

 

**PCB包括**

- **记账信息**: 执行时间

- **进程状态 (status)**
- **CPU调度信息**: 进程ID, 用户, 是否可以执行, 进程优先级等
- **CPU寄存器中的信息**
  - **程序控制器 (PC)**: 进程下一个指令的地址
- **内存管理信息**: 虚拟地址空间, 转换表
- **I/O状态信息**: 已经打开的文件





## 进程的生命周期

![](http://m.qpic.cn/psc?/V13mdl0c1ilKRz/w47sCHZ1vIeYe.9hWkknXW*H5U8*R0aPw4VOqCbtRSx3*CiDYUtDA.*MuHmRZfwKGVC58tTcGUeWJ.Dkgzw38A!!/b&bo=XAPDAVwDwwEDCSw!&rf=viewer_4)

- **创建**
- **就绪**
- **运行**
- **等待**
- **结束**: 进程已经完成运行





## 进程调度 (scheduling)

涉及多个队列, 有: **就绪队列**, 每个I/O设备都有自己的 **设备队列**



当进程分配到CPU并执行是,可能发生下面几种情况:

- 进程发出I/O请求, 并被放到I/O队列中
- 进程可能创建一个子进程, 并等待其结束
- 进程可能会由于中断而强制释放CPU, 并被放回就绪队列中



**如何调度**

**I/O为主的进程**和**CPU为主的进程**相结合





## 与进程有关的系统调用

#### fork()

**fork()系统调用创建一个当前系统的拷贝, 但是会有一个新的进程ID **

**返回值**

- **大于0**
  - 运行在旧程序中
  - 返回值为新进程的PID

- **等于0**
  - 运行在子程序中

- **小于0**
  - 出现了错误



#### exec()

**PID不变, 但是用新的进程替换原有进程**



#### wait()



#### signal()





## 进程间通信

**消息传递 和 共享内存**



**消息传递**

同内核通信

- 适合传递少量数据
- 更容易实现



**共享内存**

共享内存中操作

- 更快的速度
- 开销较小 (只需分配内存是使用系统调用)





## 线程控制器的交还

#### 内部事件

- I/O事件
  - 请求I/O同时, 也会把控制权交回
- 等待其他线程的 **signal**
- 线程主动触发 **yield()** 函数



**外部事件**

- 定时器 (timer)
- 各种中断







## 线程 (thread)

- 线程之间没有保护

**对于一些active的东西, 如 register 和 stack, 这些是 thread 每一个都有的**

**对于一些 passive 的东西, 如内存空间中 code, data, global variables, heap,  I/O状态, 这些是公用的, thread不提供保护**



- 







## 程序, 进程, 线程之间的关系

**一个程序实例中包含一个或者多个进程**



**一个进程中包含一个或者多个线程**



**程序是一个被动的实体, 进程是一个活动的实体**

**当这个线程是处理器上寄存器的宿主时, 我们说这个线程正在运行**



进程: 保护

线程: 并发